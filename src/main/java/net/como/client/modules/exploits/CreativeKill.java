package net.como.client.modules.exploits;

import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import net.como.client.ComoClient;
import net.como.client.commands.structures.Command;
import net.como.client.config.settings.Setting;
import net.como.client.config.specials.Mode;
import net.como.client.events.Event;
import net.como.client.modules.Module;
import net.como.client.utils.ChatUtils;
import net.como.client.utils.ClientUtils;
import net.como.client.utils.InteractionUtils;
import net.como.client.utils.NbtUtils;
import net.minecraft.client.world.ClientWorld;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.item.ItemStack;
import net.minecraft.item.Items;
import net.minecraft.nbt.StringNbtReader;
import net.minecraft.util.Hand;
import net.minecraft.util.math.Vec3d;

public class CreativeKill extends Module {
    // This is the most over-engineered module I've ever made
    // I'm sorry

    public abstract class KillMethod {
        protected PlayerEntity target;
        public abstract void perform();

        public void start(PlayerEntity target) {
            this.setTarget(target);
            this.perform();
        }

        public void start() {
            this.start(this.getTarget());
        }
        public void stop() {
            CreativeKill.this.remove(this);
        }

        protected ItemStack createPotion(Vec3d pos, Vec3d velocity) {
            // Create the potion
            ItemStack stack = new ItemStack(Items.BAT_SPAWN_EGG);
    
            // Create the nbt
            try {
                stack.setNbt(StringNbtReader.parse(
                    "{EntityTag:{Item:{Count:1b,id:\"minecraft:splash_potion\",tag:{CustomPotionEffects:[{ShowParticles:1b,Duration:20,Id:6b,Amplifier:125b}],Potion:\"minecraft:awkward\"}},Pos:[" + pos.x + "d," + pos.y + "d," + pos.z + "d],Motion:[" + velocity.x + "d,"+ velocity.y + "d," + velocity.z + "d],id:\"minecraft:potion\",LeftOwner:1b}}"
                ));
            } catch (Exception e) {
                e.printStackTrace();
                return null;
            }
    
            return stack;
        }

        protected ItemStack createPotion(Vec3d pos) {
            return createPotion(pos, Vec3d.ZERO);
        }

        protected void kill(PlayerEntity player, Vec3d offset, boolean refresh) {
            if (player == null) return;

            Vec3d pos = player.getLerpedPos(1).add(offset);
    
            // Create the potion
            ItemStack stack = createPotion(pos);
    
            // Spawn the potion
            NbtUtils.giveItem(stack, refresh);
    
            // Throw the potion
            InteractionUtils.fireActive(Hand.MAIN_HAND);
    
            // Remove the potion
            NbtUtils.giveItem(new ItemStack(Items.AIR), refresh);
        }

        // Wrappers
        protected void kill(Vec3d offset, boolean refresh) {
            kill(this.getTarget(), offset, refresh);
        }
        protected void kill(boolean refresh) {
            kill(this.getTarget(), this.getOffset(), refresh);
        }
        protected void kill() {
            kill(this.shouldRefresh());
        }

        public PlayerEntity getTarget() {
            return target;
        }

        public void setTarget(PlayerEntity target) {
            this.target = target;
        }

        public Vec3d getOffset() {
            double x = CreativeKill.this.getDoubleSetting("OffsetX");
            double y = CreativeKill.this.getDoubleSetting("OffsetY");
            double z = CreativeKill.this.getDoubleSetting("OffsetZ");

            return new Vec3d(x, y, z);
        }

        public boolean shouldRefresh() {
            return CreativeKill.this.getBoolSetting("RefreshItem");
        }

        protected boolean isTargetVisible() {
            // Get all the players in the world
            for (PlayerEntity player : ComoClient.getClient().world.getPlayers()) {
                // Check if the player is the target
                if (player != this.getTarget()) continue;

                return true;
            }

            return false;
        }
    }
    public abstract class ThreadedKillMethod extends KillMethod {
        protected Thread thread;
        protected boolean running = false;

        protected boolean shouldDelay = true;

        @Override
        public void start(PlayerEntity target) {
            if (this.running) return;

            this.setTarget(target);
            
            this.running = true;
            thread = new Thread(() -> {
                this.threadMain();
            });

            this.thread.setName(this.getClass().getSimpleName());

            thread.start();
        }

        protected void threadMain() {
            while (!this.shouldStop()) {
                this.perform();
                this.doDelay();
            }

            this.stop();
        }

        /**
         * Delays current thread for the specified delay
         */
        protected void doDelay() {
            if (!this.shouldDelay) return;

            try {
                Thread.sleep(this.getDelay());
            } catch (Exception e) {}
        }

        @Override
        public void stop() {
            this.running = false;
            super.stop();
        }

        /**
         * Gets the delay between each kill
         * @return delay in milliseconds
         */
        public long getDelay() {
            return CreativeKill.this.getIntSetting("ThreadDelay");
        }

        /**
         * Gets if the thread is running
         * @return true if running, false if not
         */
        public boolean isRunning() {
            return this.running;
        }

        @Override
        public boolean shouldRefresh() {
            return false;
        }

        protected boolean shouldStop() {
            return 
                   !this.isRunning()
                || !ClientUtils.inGame()
                || this.getTarget() == null
                || !this.getTarget().isAlive()
                || !this.isTargetVisible();
        }
    }
    
    public CreativeKill() {
        super("CreativeKill");

        this.setDescription("Kills a player in creative mode");
        this.setCategory("Exploit");

        this.addSetting(new Setting("Mode", new Mode("Spam", "Basic")));
        this.addSetting(new Setting("TargetName", "gingerchicken") {
            @Override
            public boolean shouldShow() {
                return !CreativeKill.this.getBoolSetting("Daemon");
            }

            @Override
            public List<String> getSuggestions() {
                List<String> suggestions = new ArrayList<>();

                // Get the world
                ClientWorld world = ComoClient.getClient().world;
                if (world == null) return suggestions;

                for (PlayerEntity player : world.getPlayers()) {
                    suggestions.add(player.getEntityName());
                }

                return suggestions;
            }

            {
                this.setCategory("Single Use");
            }
        });

        // Offset
        this.addSetting(new Setting("OffsetX", 0.0d) {{
            this.setMin(-5.0d);
            this.setMax(5.0d);
            this.setCategory("Offset");
        }});
        this.addSetting(new Setting("OffsetY", 2.1d) {{
            this.setMin(-5.0d);
            this.setMax(5.0d);
            this.setCategory("Offset");
        }});
        this.addSetting(new Setting("OffsetZ", 0.0d) {{
            this.setMin(-5.0d);
            this.setMax(5.0d);
            this.setCategory("Offset");
        }});

        this.addSetting(new Setting("RefreshItem", true));

        this.addSetting(new Setting("Daemon", true) {{
            this.setDescription("When disabled, it will only kill a single target and then stop (only takes effect on toggle)");
        }});

        this.addSetting(new Setting("ThreadDelay", 100) {{
            this.setMin(1);
            this.setMax(1000);
        }});

        this.methods.put("Spam", SpamMethod.class);
        this.methods.put("Basic", BasicMethod.class);
    }

    protected HashMap<String, Class<? extends KillMethod>> methods = new HashMap<>();
    protected List<KillMethod> methodQueue = new ArrayList<>();
    protected boolean doAutoDisable = false;

    public void stopAll() {
        List<KillMethod> methodsToKill = new ArrayList<>(this.methodQueue);

        for (KillMethod method : methodsToKill) {
            method.stop();
        }
    }

    public void remove(KillMethod method) {
        methodQueue.remove(method);
        this.performAutoDisable();
    }

    @Override
    public String listOption() {
        return String.valueOf(this.methodQueue.size());
    }

    @Override
    public void fireEvent(Event event) {}

    @Override
    public void activate() {
        this.doAutoDisable = !this.isDaemon();
        this.isActiveDaemon = this.isDaemon();

        if (this.doAutoDisable) {
            this.trigger();
        }
    }

    protected boolean isActiveDaemon = false;

    @Override
    public void deactivate() {
        this.doAutoDisable = false;
        this.stopAll();
    }

    public boolean isDaemon() {
        return this.getBoolSetting("Daemon");
    }

    protected boolean hideEnableMessage() {
        boolean shouldHide = !this.isActiveDaemon;

        if (shouldHide) ChatUtils.hideNextChat = true;

        return shouldHide;
    }

    @Override
    public void onEnabled() {
        this.hideEnableMessage();
        super.onEnabled();
    }

    @Override
    public void onDisabled() {
        this.hideEnableMessage();
        super.onDisabled();
    }

    protected void performAutoDisable() {
        if (!this.doAutoDisable) return;

        this.disable();
    }

    public KillMethod trigger(PlayerEntity target, String method) {
        // Get the method class
        Class<? extends KillMethod> methodClass = this.methods.get(method);

        // Check if the method exists
        if (methodClass == null) {
            this.performAutoDisable();
            return null;
        }

        // Create the method
        KillMethod killMethod = null;
        try {
            // Get the constructor
            Constructor<? extends KillMethod> constructor = methodClass.getConstructor(CreativeKill.class);

            // Create the method
            killMethod = constructor.newInstance(this);
        } catch (Exception e) {
            e.printStackTrace();
            this.performAutoDisable();
            return null;
        }

        // Add the method to the queue
        methodQueue.add(killMethod);

        // Start the method
        killMethod.start(target);

        return killMethod;
    }
    public KillMethod trigger(PlayerEntity target) {
        return this.trigger(target, this.getModeSetting("Mode").getStateName());
    }
    public KillMethod trigger() {
        PlayerEntity target = this.getTarget();

        // Check if the target is valid
        if (target == null) {
            this.performAutoDisable();
            return null;
        }

        return this.trigger(target);
    }

    public PlayerEntity getTarget(String playerName) {
        if (ComoClient.getClient().world == null) return null;

        // Get all the players in the world
        for (PlayerEntity player : ComoClient.getClient().world.getPlayers()) {
            // Check if the player is the target
            if (!player.getEntityName().equalsIgnoreCase(playerName)) continue;

            // Make sure that the player is alive
            if (!player.isAlive()) continue;

            return player;
        }

        this.displayMessage(ChatUtils.RED + "Player not found.");
        return null;
    } 
    public PlayerEntity getTarget() {
        return this.getTarget(this.getStringSetting("TargetName"));
    }

    // Methods

    public class SpamMethod extends ThreadedKillMethod {
        @Override
        public void perform() {
            this.kill();
        }

        public SpamMethod() {
            super();
        }
    }

    public class BasicMethod extends KillMethod {
        @Override
        public void perform() {
            kill();
            this.stop();
        }
    }

    // Commands

    @Override
    public Iterable<Command> getCommands() {
        List<Command> commands = new ArrayList<>();

        commands.add(new PerformCommand());
        commands.add(new StopCommand());

        return commands;
    }

    public abstract class KillCommand extends Command {

        public KillCommand(String command, String helpText, String description) {
            super(command, helpText, description);
        }

        @Override
        public void displayChatMessage(String message) {
            CreativeKill.this.displayMessage(message);
        }

        @Override
        public Boolean trigger(String[] args) {
            // Make sure that the module is enabled
            if (!CreativeKill.this.isEnabled()) {
                this.displayChatMessage(ChatUtils.RED + "Module is not enabled.");
                return true;
            }

            // Make sure that the Creative kill module is in daemon mode
            if (!CreativeKill.this.isActiveDaemon) {
                this.displayChatMessage(ChatUtils.RED + "Module is not in daemon mode, if you have enabled daemon mode, please re-enable the module.");
                return true;
            }

            return false;
        }
    }

    public class PerformCommand extends KillCommand {
        public PerformCommand() {
            super("perform", "perform <player name> <method name>", "Perform a kill on a player");
        }

        @Override
        public Boolean trigger(String[] args) {
            if (super.trigger(args)) return true;

            String targetName = args.length == 0 ? CreativeKill.this.getStringSetting("TargetName") : args[0];

            // Get the target
            PlayerEntity target = CreativeKill.this.getTarget(targetName);

            // Check if the target is valid
            if (target == null) {
                // A message should have already been displayed
                // CreativeKill.this.displayMessage(ChatUtils.RED + "Player not found.");

                return true;
            }

            // Get the kill method
            String methodName = args.length == 0 ? "" : args[args.length - 1];

            // Check that the method exists
            if (!CreativeKill.this.methods.containsKey(methodName)) {
                // Default to the current mode
                methodName = CreativeKill.this.getModeSetting("Mode").getStateName();
            }

            // Display a message
            CreativeKill.this.displayMessage("Performing kill on " + ChatUtils.GREEN + target.getEntityName() + ChatUtils.WHITE + " using " + ChatUtils.GREEN + methodName + ChatUtils.WHITE + " method.");

            // Trigger the kill
            CreativeKill.this.trigger(target, methodName);

            return true;
        }

        @Override
        public List<String> getSuggestions() {
            List<String> suggestions = new ArrayList<>();

            // Add the player names
            for (PlayerEntity player : ComoClient.getClient().world.getPlayers()) {
                suggestions.add(player.getEntityName());
            }

            // Add the method names
            suggestions.addAll(CreativeKill.this.methods.keySet());

            return suggestions;
        }
    }
    public class StopCommand extends KillCommand {
        public StopCommand() {
            super("stop", "stop", "Stop all kill methods");
        }

        @Override
        public Boolean trigger(String[] args) {
            if (super.trigger(args)) return true;
            
            int totalProcesses = methodQueue.size();

            CreativeKill.this.stopAll();

            CreativeKill.this.displayMessage("Stopped " + ChatUtils.GREEN + totalProcesses + ChatUtils.WHITE + " processes.");

            return true;
        }
    }
}
